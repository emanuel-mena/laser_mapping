from dataclasses import dataclass
from typing import List, Iterable, Tuple, Dict, Any


@dataclass
class LaserPoint:
    """
    Single 3D laser sample.

    Attributes
    ----------
    x, y, z : float
        3D coordinates of the measured point (in your global coordinate system).
    distance : float
        Raw distance returned by the sensor (same units as your hardware).
    """
    x: float
    y: float
    z: float
    distance: float


class LaserMapper3D:
    """
    Generic 3D mapper for laser scanning.

    This class is fully independent from the specific laser hardware.
    You only feed it with already-computed 3D coordinates (x, y, z)
    plus the raw measured distance, and it will store everything and
    allow exporting in common 3D formats (PLY, OBJ).
    """

    def __init__(self, units: str = "meters") -> None:
        """
        Parameters
        ----------
        units : str
            Human-readable units for the coordinate system (e.g. 'meters', 'mm').
            Only stored as metadata; does not affect calculations.
        """
        self.units = units
        self._points: List[LaserPoint] = []

    # =====================================================
    # Data insertion
    # =====================================================
    def add_sample(self, x: float, y: float, z: float, distance: float) -> None:
        """
        Add a single measurement to the map.

        Parameters
        ----------
        x, y, z : float
            3D coordinates of the hit point (already computed by your code).
        distance : float
            Raw distance reported by the sensor for this measurement.
        """
        self._points.append(LaserPoint(x, y, z, distance))

    def add_samples(self, samples: Iterable[Tuple[float, float, float, float]]) -> None:
        """
        Add multiple samples at once.

        Parameters
        ----------
        samples : iterable of (x, y, z, distance)
        """
        for x, y, z, distance in samples:
            self.add_sample(x, y, z, distance)

    # =====================================================
    # Accessors
    # =====================================================
    def get_points(self) -> List[LaserPoint]:
        """
        Return all samples as a list of LaserPoint objects.
        """
        return list(self._points)

    def get_xyz_array(self) -> List[Tuple[float, float, float]]:
        """
        Return only the (x, y, z) coordinates as a list of tuples.
        Useful when you only need the point cloud without extra attributes.
        """
        return [(p.x, p.y, p.z) for p in self._points]

    # =====================================================
    # Export helpers
    # =====================================================
    def to_ply(self) -> str:
        """
        Export the current map as an ASCII PLY point cloud.

        - Each point is stored as a vertex.
        - The 'distance' attribute is stored as a per-vertex scalar property.
        """
        num_vertices = len(self._points)

        header_lines = [
            "ply",
            "format ascii 1.0",
            f"comment Generated by LaserMapper3D (units: {self.units})",
            f"element vertex {num_vertices}",
            "property float x",
            "property float y",
            "property float z",
            "property float distance",
            "end_header",
        ]

        body_lines = [
            f"{p.x} {p.y} {p.z} {p.distance}"
            for p in self._points
        ]

        return "\n".join(header_lines + body_lines) + "\n"

    def to_obj(self) -> str:
        """
        Export the current map as an OBJ file.

        - Each point is stored as a 'v x y z' vertex.
        - No faces are generated; this is a point cloud only.
        - 'distance' is NOT stored (OBJ has no standard scalar per-vertex property).
        """
        lines = [
            f"# Generated by LaserMapper3D (units: {self.units})",
            "# OBJ point cloud",
        ]

        for p in self._points:
            lines.append(f"v {p.x} {p.y} {p.z}")

        return "\n".join(lines) + "\n"

    def save_ply(self, path: str) -> None:
        """
        Save the current map as a .ply file on disk.
        """
        with open(path, "w", encoding="utf-8") as f:
            f.write(self.to_ply())

    def save_obj(self, path: str) -> None:
        """
        Save the current map as a .obj file on disk.
        """
        with open(path, "w", encoding="utf-8") as f:
            f.write(self.to_obj())

    # =====================================================
    # Metadata export (optional)
    # =====================================================
    def to_dict(self) -> Dict[str, Any]:
        """
        Export the whole map as a pure-Python dict (JSON-friendly).
        Useful if you want to transfer the data over a network.
        """
        return {
            "units": self.units,
            "points": [
                {"x": p.x, "y": p.y, "z": p.z, "distance": p.distance}
                for p in self._points
            ],
        }

    # Optional: clear map
    def clear(self) -> None:
        """
        Remove all stored samples.
        """
        self._points.clear()
